from __future__ import absolute_import
import string

import pipeline.infrastructure as infrastructure
import pipeline.infrastructure.api as api
from . import adapters
from . import bandpassworker
from . import channelbandpass
from . import common

from pipeline.h.heuristics import echoheuristic as echoheuristic
from pipeline.hif.heuristics import bporder as bporder

LOG = infrastructure.get_logger(__name__)



class PolynomialBandpassInputs(common.CommonBandpassInputs):
    def __init__(self, context, output_dir=None,
                 #
                 vis=None, caltable=None, 
                 # data selection arguments
                 field=None, spw=None, antennas=None, intent=None,
                 # solution parameters
                 solint=None, combine=None, refant=None, minblperant=None,
                 solnorm=None, fillgaps=None, degamp=None, degphase=None,
                 visnorm=None, maskcenter=None, maskedge=None, append=None,
                 # preapply calibrations
                 opacity=None, parang=None,
                 # calibration target
                 to_intent=None, to_field=None):
        self._init_properties(vars())

    def _printable(self, heuristic):
        if isinstance(heuristic, echoheuristic.EchoHeuristic):
            return heuristic()
        return heuristic 

    @property
    def bandtype(self):
        return 'BPOLY'

    @property
    def degamp(self):
        return self._degamp

    @degamp.setter
    def degamp(self, value):
        if value is None:
            value = bporder.BPOrder()
        if not isinstance(value, api.Heuristic):
            value = echoheuristic.EchoHeuristic(value)
        self._degamp = value

    @property
    def degphase(self):
        return self._degphase

    @degphase.setter
    def degphase(self, value):
        if value is None:
            value = bporder.BPOrder()
        if not isinstance(value, api.Heuristic):
            value = echoheuristic.EchoHeuristic(value)
        self._degphase = value


# extending BandpassWorker allows us to use its analyse, otherwise we'd extend
# StandardTaskTemplate.
class PolynomialBandpass(bandpassworker.BandpassWorker):
    Inputs = PolynomialBandpassInputs

    def prepare(self):
        inputs = self.inputs
        results = common.BandpassResults()

        # If both degamp and degphase are EchoHeuristics, meaning the user has
        # supplied both values, then we don't need to generate a channel
        # bandpass for analysis.
        if not isinstance(inputs.degamp, echoheuristic.EchoHeuristic)\
            and not isinstance(inputs.degphase, echoheuristic.EchoHeuristic):
            pass
            # TODO: optimise this!

        # The heuristics compute the required polynomial order by 
        # analysing a channel bandpass caltable. Generate this caltable
        # and add the result to our subtasks. 
        channelbandpass_result = self._do_channelbandpass()
        results.preceding.append(channelbandpass_result)

        # Adapt the heuristics so that we can call them with pipeline domain
        # objects
        degamp_fn = adapters.DegAmpAdapter(inputs.degamp)
        degphase_fn = adapters.DegPhaseAdapter(inputs.degphase)
        
        # fix the caltable name to its current value so that all appends go
        # into the one file
        inputs.caltable = inputs.caltable
    
        # Loop through the caltables generated by the channel bandpass,
        # computing the best parameters as we go.
        append = False
        tasks = []
        for caltable in channelbandpass_result.final:            
            worker_inputs = self._get_bandpassworker_inputs()
            
            for spw in string.split(caltable.spw, ','):
                worker_inputs.append = append
                worker_inputs.spw = spw
                worker_inputs.degamp = degamp_fn(inputs.ms, caltable, spw)
                worker_inputs.degphase = degphase_fn(inputs.ms, caltable, spw)
    
                task = bandpassworker.BandpassWorker(worker_inputs)
                tasks.append(task)
    
                append = True

        for task in tasks:
            worker_result = self._executor.execute(task)
            results.pool.extend(worker_result.final)
         
        return results

    def _get_bandpassworker_inputs(self):
        # we basically want to create a new worker inputs and then copy across
        # all values from our polynomial inputs to the worker inputs.
        poly_inputs = self.inputs
        poly_task_args = poly_inputs._get_task_args()        
        return bandpassworker.BandpassWorker.Inputs(poly_inputs.context,
            bandtype=poly_inputs.bandtype, **poly_task_args)

    def _do_channelbandpass(self):
        inputs = self.inputs
        bandpass_inputs = channelbandpass.ChannelBandpass.Inputs(inputs.context,
            vis         = inputs.vis, 
            caltable    = None,
            # data selection arguments
            field       = inputs.field,
            spw         = inputs.spw,
            intent      = inputs.intent,
            # solution parameters
            solint      = inputs.solint,
            combine     = inputs.combine,
            refant      = inputs.refant,
            minblperant = inputs.minblperant,
            minsnr      = None,
            solnorm     = inputs.solnorm,
            fillgaps    = inputs.fillgaps)

        bandpass_task = channelbandpass.ChannelBandpass(bandpass_inputs)
        return self._executor.execute(bandpass_task, merge=False)
