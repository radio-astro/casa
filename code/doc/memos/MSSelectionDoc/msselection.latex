\documentclass[12pt, twoside]{article}
%\documentstyle[12pt,amsmath]{article}
\usepackage{html}
\usepackage{epsf}
\usepackage{amsmath}
\usepackage[dvips]{graphicx, color}  % The figure package
\usepackage{palatino}
\usepackage{natbib}     % Package used for bib. citation
\usepackage{txfonts}
%\usepackage{MnSymbol,wasysym}
\usepackage{marvosym}

\markboth{S. Bhatnagar}{MeasurementSet Selection Syntax}
\pagestyle{myheadings}

\setlength{\textheight}{23.0cm}
\setlength{\textwidth}{17.00cm}
\setlength{\topmargin}{-1.0cm}
\setlength{\oddsidemargin}{0.1cm}
\setlength{\evensidemargin}{0.1cm}
%\setlength{\parskip}{5pt}
%\setlength{\parindent}{20pt}

%\evensidemargin -0.7cm
%\oddsidemargin 1.5cm
%\textwidth 13cm
%\topmargin -1.5cm
%\textheight 23cm
%\parskip 1ex    % White space between paragraphs amount
%\sffamily
\renewcommand{\familydefault}{\sfdefault}


\newcommand{\MSS} {{\tt MSSelection}}
\newcommand{\MSSelection}    {\htmladdnormallinkfoot{{\tt MSSelection}}{http://casa.nrao.edu/active/docs/doxygen/html/classcasa\_1\_1MSSelection.html}}
\newcommand{\MSSelectionError} {\htmladdnormallinkfoot{{\tt MSSelectionError}}{http://casa.nrao.edu/active/docs/doxygen/html/classcasa\_1\_1MSSelectionError.html}}
\newcommand{\MSSelectionErrorHandler} {\htmladdnormallinkfoot{{\tt MSSelectionErrorHandler}}{http://casa.nrao.edu/active/docs/doxygen/html/classcasa\_1\_1MSSelectionErrorHandler.html}}
\newcommand{\CalTables} {\htmladdnormallinkfoot{{\tt CalTables}}{http://casa.nrao.edu/active/docs/doxygen/html/classcasa\_1\_1CalTable.html}}
\newcommand{\PDFVersion} {\htmladdnormallinkfoot{PDF Version}{http://www.aoc.nrao.edu/~sbhatnag/misc/msselection.pdf}}


\begin{document}
\title{MeasurementSet Selection Syntax}
\author{S. Bhatnagar\\ NRAO, Socorro}
\date{June 15, 2007\\{\small (Updated: April 25, 2014)}}
\maketitle
\normalsize
\begin{center}
  \PDFVersion
\end{center}

\begin{abstract}
  This note describes the syntax for the various expressions for
  selecting data from the Measurement Set, implemented in the
  \MSSelection\ module of CASACore.  All expressions consist of a
  comma or semi-colon separated list of specifications.  Except
  channel selection, the final product of parsing the expressions is a
  Table Expression Node (TEN) which can be used to construct a table
  with only the selected rows.  Higher level global methods to return
  a selected table, given the user supplied expressions, are also
  provided as part of this module.

  Error handling is done via the C++ exception handling mechanism.
  The exceptions thrown by the \MSS\ module are of type
  \MSSelectionError\ which is derived from {\tt AipsError} class.  The
  exceptions generated from each individual expression parser are
  further specializations of the {\tt MSSeletionError} class.
  Application layer code therefore can have a finer level control on
  error handling.  The module now also support externally plug-able
  error handlers of type \MSSelectionErrorHandler. This allows
  application layer code to have control on the resolution mechanism
  of the exceptional states that may be reached during the parsing
  cycle.

  The \MSS\ module now can also be used for other tables
  that follow the general data base design of the {\tt
    MeasurementSet}.  The CASA \CalTables\ is an example which also
  uses the \MSS\ module for data selection.
\end{abstract}
\newpage
\tableofcontents
\newpage

\section{General Syntax}
\label{Sec:GENERALSYNTAX}
A \MSS\ expression consists of a comma separated list of
specifications.  Specifications are typically strings or numbers.
Strings and numbers can be mixed to form a single list.  Elements of
the list which can be converted to integers are treated as integer
index specification.  Elements which do not get parsed as numbers are
treated as strings.  Where appropriate, strings are matched against
names.  Depending upon the content of a string, it can be used as
regular expressions or pattern.  Where appropriate, physical
quantities (numbers with appropriate units) can also be used.

A blank selection expression is interpreted as "no selection to be
applied to the MS".  Hence a blank expression effectively implies
"select all".

\subsection{Number format}
\label{Sec:NUMBERS}

Integers can be of any length (in terms of characters) and composed of
the characters in the range 0-9. Where appropriate, negative values
can be given using the '-' character.  Floating point numbers can be
in the standard format:

\begin{itemize}
\item   DIGIT.DIGIT  : e.g. 10.56
\item   DIGIT.       : e.g. 10.
\item   .DIGIT       : e.g. .56
\end{itemize}
or in the mantissa-exponent format (e.g. 10.56e-1).  If a floating
point number is given where only integers are expected (e.g. indexes),
the floating point value is truncated to the nearest integer.

\subsection{Range specification}
\label{Sec:RANGE}
Range of numbers (integers or real numbers) can be given in the format
N0$\sim$N1.  Integer ranges are expanded into a list of integers
starting from N0 (inclusive) to N1 (inclusive).  Range of real numbers
is used to select all values between N0 and N1 (including the
boundaries). E.g.

Integer ranges:

\begin{itemize}
\item 10$\sim$30 implies all integers in the range [10,30]
\item 10.1$\sim$30.5 implies all integers in the range [10,30]
\end{itemize}
Floating point ranges:
\begin{itemize}
\item 10$\sim$30 implies all values in the range [10.0, 30.0]
\item 10.5$\sim$30.7 implies all values in the range [10.5, 30.7]
\item 1.05e1 $\sim$ 3.07e1 implies all values in the range [10.5,
  30.7]
\end{itemize}

\subsection{Units}

Wherever appropriate, units can be optionally specified.  Values with
units are converted to the units in the Measurement Set (which uses
the MKS-system).  For ranges, the units are specified only once (at
the end) and it applies to both the range boundaries. E.g.

\begin{itemize}
\item   1421.07MHz implies 1421.07e6 Hz
\item 1421$\sim$1500MHz implies all frequencies in the range [1421.0,
  1500.0]MHz.
\end{itemize}

\subsection{Strings}
\label{Sec:STRINGS}
String matching can be done in three ways.  Any component of a comma
separated list that cannot be parsed as number/number range/physical
quantity is treated as a regular expression or a literal string.  If
the string does not contain the characters '*', '{', '}' or '?', it is
treated as a literal string and used for exact matching.  If any of
the above mentioned characters are part of the string, it is used as a
regular expression.  As a result, for most cases, the user does not
need to supply any special delimiters for literal strings and/or
regular expressions.  However if it is required that the string be
matched exclusively as a regular expression, it can be supplied within
a pair of '/' as delimiters.  A string enclosed within double quotes
('"') is used exclusively for pattern matching (patterns are a
simplified form of regular expressions - used in most UNIX commands
for string matching). Patterns are internally converted to equivalent
regular expressions before matching.  Read elsewhere (e.g. use command
"info regex", or visit \htmladdnormallinkfoot{this link}{http://www.regular-expressions.info}) for
details of regular expression and patterns.

Strings can include any character except the following:

\begin{verbatim}
   ','   ';' '"'  '/'  ':' and NEWLINE
\end{verbatim}
(these are reserved characters for \MSS\ expression syntax).
Strings that do not contain any of the characters used to construct
regular expressions or patterns are used for exact matches.  Although
it is highly discouraged to have name in the database containing the
above mentioned reserved characters, if one DOES choose to include the
reserved characters are part of names etc., those names can only be
matched against quoted strings (since regular expression and patterns
are super-set of literal strings. I.e. literal string is a valid
regular expression also).  This leaves the list '"', '*', '?', '{' and
  '}' as the list of printable character that cannot be part of a name
(i.e., a name containing this character can never be matched in a
\MSS\ expression).  If a need is felt to include these as well,
an escape mechanism can be included later (but I would prefer to
enforce that {\bf at least} these characters not be part of any
name!).  Following are some examples of strings/regular
expressions/patterns:

\begin{itemize}
\item The string LBAND will be used as a literal string for exact
  match.  This will match only "LBAND".
   
\item The string {\tt *BAND*} will be used as a string pattern for
  matching.  This will match any string which has "BAND" in it.
 
\item The string {\tt"*BAND*"} will be used as a string pattern for
  matching.  This will also match any string which has the string
  "BAND" in it.

\item The string /.*BAND.*/ will be used as a regular expression.
  This will also match any string which has the string "BAND" in it.
  (.* operator has the same meaning as the '*' operator of patterns).
\end{itemize}

\subsection{Handling of blanks}

In most cases, blanks are treated as white-spaces (i.e., insertion of
blanks anywhere in the expression has no effect), except in the case
of Field Selection Expressions (see Section~\ref{FIELDEXPR}).  Blanks
are allowed as part of the field names.  Blanks around the delimiting
characters (',' , ';' , '\&' etc.) are ignored.  For field names,
blanks after the first valid name character and before the last valid
name character are included as part of the name.  Hence

\begin{itemize}
\item field={\tt A , B , C} is same as field={\tt A,B,C}
\item field={\tt A , BB~BB , C} is same as field={\tt A,BB~BB,C}
  (first name is "A", second name is "BB~BB" and the third name is
  "C")
\item baseline={\tt 1 , 2 , 3 \& 4 , 5 , 6 ; 10 $\sim$ 11 \& 20 $\sim$
  30} is same as\\ baseline={\tt 1,2,3\&4,5,6;10$\sim$11\&20$\sim$30}
\end{itemize}

\section{Time selection}

Time selection expression is a comma separated list of time
specifications. Time can be specified in the format
YYYY/MM/DD/HH:MM:SS.FF.  Fields (i.e., YYYY, MM, DD, HH, MM, SS and
FF), starting from left to right, can be omitted.  Omitted fields will
be replaced by context sensitive defaults as explained below.

T0, T1 and dT in the following description are time specifications.

\subsection{Syntax}

\begin{itemize}
\item time~=~~{\tt T0$\sim$T1}

      Selects all time stamps starting from T0 to T1.  Fields missing
      in T0 are replaced by the fields in the time stamp of the first
      valid selected row in the MS.  Fields missing in T1 are replaced
      by the corresponding fields of T0 (after its defaults are set).
\item time~=~~{\tt T0}

      Selects all time stamps that are within an integration time of
      T0.  Integration time is determined from the first valid
      selected row (more rigorously, an average integration time
      should be computed).  Default settings for the missing fields of
      T0 are as described in bullet (1) above.
\item time~=~~{\tt T0+dT}

      Selects all time stamps starting from T0 and ending with time
      value given by T0+dT. Defaults of T0 are set as usual described
      in bullet (1) above.  Defaults for dT are set from the time
      corresponding to MJD=0.  I.e. dT is an specification of length
      of time from nominal "start of time" (the time stamp of the
      first valid selected row of the MS).

\item time~=~~{\tt$>$T0} 

      Selects all times greater than T0. 

\item time~=~~{\tt$<$T0} 

      Selects all times less than T0. Default settings for T0 are as
      above.
\end{itemize}

\section{Antenna/Baseline Selection}

This expression is used to perform baseline based selections.
Baseline can be specified as a pair of antenna specifications.  Since
antenna specification can itself be a list of antennas, the expression
allows a rich selection syntax which is simple for simple selections.

ANT in the description below is a comma-separated list of antenna
specifications.  A baseline specification is an single ANT, ANT
followed by an operator or a pair of ANT separated by an operator.  A
baseline expression is single baseline specification or a semi-colon
separated list of baseline specifications.

\subsection{Syntax}

\subsubsection{Antenna specification}

An ANT can be given as a single \hyperref{string}{string (see Section
}{)}{Sec:STRINGS} (literal/pattern/regular expression), single integer
ID, a \hyperref{range}{range (see Section }{)}{Sec:RANGE} of integer
IDs or a comma separated list of integers.  For VLA-specific reasons
(see Section~\ref{VLACONVENTION}), {\bf only} for antenna
specifications, integers are first converted to strings and matched
against the antenna names.  E.g.

\begin{itemize}
\item {\tt VLA:N1} corresponds to antenna named "VLA:N1".
\item {\tt 1,2,3} corresponds to antennas {\bf named} "1", "2" and
  "3".
\item {\tt 1$\sim$3} corresponds to antennas {\bf named} "1", "2" and
  "3".
\item {\tt VLA:N*} corresponds to all antennas who's name starts with
  "VLA:N".
\end{itemize}

The precise logic applied to the antenna specification (ANT) is as
follows:

\begin{enumerate}
\item If ANT is an integer index (or a list or \hyperref{range}{range
    (see Section }{)}{Sec:RANGE}), it is first used as a name (e.g. the
  index 1 is converted to a string "1" etc.)  and matched against the
  {\tt NAME} column of {\tt ANTENNA} sub-table.  If no match is found,
  it is treated as an integer index and matched against the antenna
  indices.

\item If ANT is a string which cannot be converted to an integer, it
  is first matched against the {\tt NAME} column of the {\tt ANTENNA}
  sub-table.  If no match is found, match against the {\tt STATION}
  column is attempted.
\end{enumerate}

\subsubsection{Antenna@Station specification}

A fully qualified antenna specification can also include the station
name via the {\tt ANT@STATION} syntax.  {\tt STATION} specification
follows the same rules as antenna specification. When antenna or
station in a {\tt ANT@STATION} syntax is a comma-separated list, the
list must be enclosed in a left- and right-parenthesis pair to
distinguish it from a comma-separated list of {\tt ANT@STATION} (i.e.,
{\tt "A1@S1, A2@S2, A3@S3"} versus {\tt "(A1,A2,A3)@(S1,S2,S3)"}).  All
antennas in the {\tt ANT} part of the specification on {\it any} of
the stations in the {\tt STATION} part of the specification will be
selected.  The {\tt ANT} part of the specification is optional and
when not specified is replaced with the wild-card {\tt "*"} (i.e. {\tt
  "@STATION"} is equivalent to {\tt "*@STATION"}).

The two forms of specifications that are interpreted differently are:
\begin{enumerate}
\item List of ANT@STATION: {\tt A1@S1, A2@S2, A3@S3,....}
\item (List of ANT)@(List of STATION): {\tt (A1, A2, A3)@(S1,S2,S3)}
\end{enumerate}
First form is similar to the comma-separated list of antenna
specifications used to construct the baseline to be selected (see
Section~\ref{BASELINE_SPEC}).  The latter will select all members of
the antenna list that are on any of the stations listed in the station
list.  E.g. if antenna {\tt A1} appears on stations {\tt S1} and {\tt
  S3}, both will be selected in the second form, but only the antenna
{\tt A1} on station {\tt S1} will be selected in the first form.  Note
that the second form of specification can itself be a member of a
comma-separated list.


\subsubsection{Baseline specification}
\label{BASELINE_SPEC}

A baseline specification consists of an ANT followed by an
operator or a pair of antenna specifications separated by an operator.
Operator can be one, two or three ampersands ({\tt '\&'}):

\begin{table}[h!]
\caption{Table of allowed baseline selection operators and their meaning.} 
\begin{center}
\begin{tabular}{|c|l|}
\hline
{\bf The operator} & {\bf Operation}\\
\hline
{\tt \&} & Select only cross-correlation data\\
\hline
{\tt \&\&} & Select cross- {\it and} auto-correlation data\\
\hline
{\tt \&\&\&} & Select {\it only} auto-correlation data\\
\hline
\end{tabular}
\end{center}
\label{BASELINEOP:TAB}
\end{table}

%  {\tt
%   '\&'} selects {\it only} cross-correlation baselines, {\tt '\&\&'}
% selection cross- {\it and} auto-correlation baselines and {\tt
%   '\&\&\&'} selection {\it only} auto-correlation baselines.

Possible forms of baseline specifications are tabulated in
Table~\ref{BASELINE:TAB}.
\begin{table}[h!]
  \caption{Baseline specification syntax: ANT, ANT1 and ANT2 in the
    table below represent a comma-separated list of antennas names or
    a list of {\tt ANT@STATION} specifications.  {\tt ANT} and {\tt
      STATION} in {\tt ANT@STATION} can themselves be comma-separated
    lists enclosed in braces.}
\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf Specification} & {\bf Meaning}\\
\hline
{\tt ANT}    & Select only cross-correlation baselines between all the\\
             & antennas in {\tt ANT} and {\it all} other available antennas\\
\hline
{\tt ANT\&}  & Select only cross-correlation baselines between antennas\\
             & in {\tt ANT} only\\
\hline
{\tt ANT1 \& ANT2} & Select only cross-correlation baselines between antennas\\
                   & in {\tt ANT1} and {\tt ANT2}\\
\hline
{\tt ANT\&\&} & Select cross- {\it and} auto-correlation baselines between all\\
              & the antennas in {\tt ANT} only\\
\hline
{\tt ANT\&\&*} & Select cross- {\it and} auto-correlation baselines between all\\
               & the antennas in {\tt ANT} and {\it all} other available antennas\\
\hline
{\tt ANT1 \&\& ANT2} & Select cross- {\it and} auto-correlation baselines between\\  
                     & antennas in {\tt ANT1} and {\tt ANT2}\\
\hline
{\tt ANT\&\&\&}  & Select {\it only} auto-correlation baselines for antennas in {\tt ANT}\\
\hline
{\tt !ANT}  & Excludes all baselines involving antennas in {\tt ANT}. {\tt ANT} can be\\ 
            & any of the above expressions\\
\hline
{\tt ANT1 ; !ANT2} & {\tt ANT1} and {\tt ANT2} can be any of the above
expressions. This \\
                   & selects only cross-correlation baselines between all the\\
                   & antennas in {\tt ANT1} and {\it all} other available antennas {\bf except} \\
                   & those involving antennas in {\tt ANT2}.\\ 
\hline
\hline
{\tt A1@S1}        & Select baselines with antenna {\tt A1} on station {\tt S1} only\\
\hline
{\tt (A1,A2)@(S1,S2)}  & Select baselines with antenna {\tt A1} on station {\tt S1} or {\tt S2} and \\
                       & antenna {\tt A2} on station {\tt S1} or {\tt S2}\\
\hline
\end{tabular}
\end{center}
\label{BASELINE:TAB}
\end{table}
Formally, baseline specification is of the form {\tt
  [!]ANT[$<$OP$>$[ANT]]} (where the parts in square brackets are
optional and {\tt $<$OP$>$} can be {\tt '\&', '\&\&'} or {\tt
  '\&\&\&'}).


\subsubsection{Baseline negation operator}

The negation operator {\tt '!'} can be used to exclude a baseline
specification from the final selection. {\it Note that this is a
  baseline negation operator and not an antenna negation operator}.
The negation operator applies only to the baseline specification {\it
  immediately} following it.  E.g.,

\begin{itemize}
\item baseline={\tt !15} excludes all baselines with the antenna {\bf
  named} "15"
\item baseline={\tt!1$\sim$10} excludes {\bf all} baselines involving
  the antennas {\bf named} between "1" and "10"
\item baseline={\tt !1,3,5,7,9} excludes all baselines involving
  antennas {\bf named} "1", "3", "5", "7" and "9"
\item baseline={\tt 1$\sim$10;!5} selects all baselines involving
  antennas {\bf named} between "1" and "10" {\it except} those
  involving antenna {\bf named} "5".
\end{itemize}

Note that the negation operator {\it cannot} be applied to individual
members of the antenna specification/antenna list.  E.g. the
expression {\tt "1,2,!5,8"} is syntactically incorrect.

\subsubsection{Examples}
In the most common usage, an atomic ANT selects all baselines
containing all the antennas in ANT.  ANT\& selects only baselines
between the list of antennas in the antenna specification.  ANT1\&ANT2
selects baselines between antennas in ANT1 and ANT2 only.  E.g.

\begin{itemize}
\item baseline={\tt 1,2,3} selects baseline between antennas 1, 2 and
  3 and all other antennas.
\item baseline={\tt 1,2,3\&} selects baseline between antennas 1,2 and
  3 only.
\item baseline={\tt 1,2,3 \& 4,5,6} selects baselines between antennas
  1,2,3 and 4,5,6.
\end{itemize}
Following are more examples of baseline specification using ranges and
names:
\begin{itemize}
\item baseline={\tt 1$\sim$3} same as baseline=1,2,3
\item baseline={\tt 1$\sim$3\&} same as baseline=1,2,3\&
\item baseline={\tt 1$\sim$3 \& 4$\sim$5} same as baseline={\tt
  1,2,3\&4,5,6}
\item baseline={\tt VLA:N* \& VLA:E*} selects all baselines between
  antennas with names starting with "VLA:N" and "VLA:E".
\item baseline={\tt 21;!15} selects baselines between antenna {\bf
  named} "21" and all other available antennas, {\it except} antenna
  {\bf named} "15".  I.e, baseline "21-15" (or its conjugate, if
  present in the database) is excluded.
\end{itemize}

The full baseline selection expression is any of the examples shown
above or a semi-colon-separated list of baseline specifications.  E.g.

\begin{itemize}
\item baseline={\tt 1$\sim$3\& ; 4$\sim$5\&10$\sim$15 ; VLA:N* \&
  VLA:E*}
\end{itemize}
with each elements of the semi-colon separated list being interpreted
as explained above.


\subsection{Integers-as-names VLA naming convention}
\label{VLACONVENTION}
Antenna naming convention for VLA is such that the antenna names are
actually valid integers converted to strings.  While we feel that this
is indeed a bad idea and it will be best to translate the VLA antenna
names to something like VLA1, VLA2 in the CASA VLA filler (or
something that does reflect that its a name and not get confused with
integer indexes), for now, to accommodate the VLA tradition, the
following logic is used:

\begin{quote}
{\it  Just for antenna selection, a user supplied integer (or integer
  list) is converted to a string and matched against the antenna name.
  If that fails, the normal logic of using an integer as an integer
  and matching it with antenna index is done.}
\end{quote}
For example, if the antenna with index 17 is named "21", the string
{\tt "21,VLA22"} will expand into an antenna index list of 17,22
(assuming that the antenna named VLA22 has index 22).

If we conclude that this style of antenna selection is indeed the way
we wish to go, users should be aware that the antenna selection will
behave differently for telescopes other than VLA.  For example,
assuming that antenna with names "21","17", and "11" have indices 1,2
and 3, for VLA only a selection string "21,17,11" will select antenna
with indices 1, 2 and 3.  For other instruments where this is not the
naming convention, the same selection string ("21,17,11") will select
antennas with indices 21, 17, and 11.

%% \subsubsection{Note}

%% \begin{enumerate}
%% \item   Selection on polarization is not implemented.
%% \end{enumerate}

\section{Field Selection}
\label{FIELDEXPR}
\subsection{Syntax}

Field specifications can be literal field names, regular expressions
or patterns.  Leading and trailing blanks are stripped from the user
supplied field specifications as well as from the entries of the NAME
and field codes before being used for matching.  

Since none of the following characters are used as part of the FIELD
selection expressions, they can also be used as part of field names:
";", "\$", "\%", "!", "@", and "\#"\footnote{In case users loose their
  patience with the NRAO Observation Preparation Tool (NRAO OPT) and
  start giving field names like ``{\tt @\#!\$\%;}'', to them we can say ``...we
  understand.'' {\bf \Smiley{}}}.

Fields for which the entry in the NAME column of the the FIELD
sub-table match the literal field name/regular expression/pattern are
selected.  If a field name/regular expression/pattern fails to match
any field name, the given name/regular expression/pattern are matched
against the field code.  If still no field is selected, an exception
of type MSSelectionFieldParseError is thrown.

Field specifications can also be give by their integer IDs.  IDs can
be a single ID or a \hyperref{range}{range (see Section }{)}{Sec:RANGE}
of IDs (N0$\sim$N1).  Field ID selection can also be done using a
boolean expression.  For a field specification of the form "$>$ID",
all field IDs greater than ID are selected.  Similarly for "$<$ID" all
field IDs smaller than ID are selected.

The field selection expression is a comma-separated list of field
specifications.  E.g.

\begin{itemize}
\item field={\tt 1,2,3,4} selects field IDs 1,2,3 and 4
\item field={\tt 1$\sim$4} same as above
\item field={\tt 1$\sim$4, VIRGO A , 3C*} selects field IDs 1,2,3,4
  field named "VIRGO A" and all fields with names starting with "3C".
\end{itemize}

\section{UV Distance Selection}

\subsection{Syntax}
\label{SPWEXPR}

A uv-distance specification is given as a physical quantity (number
with units in the format N[UNIT] where UNIT is optional).  This is
referred to as UVDIST in the description below.  Units are optional
with the default unit being meter.  Units can be specified as "m"/"M"
(for Mega) or "k"/"K" (for Kilo) followed by "m"/"M" (for meter) or
"lambda"/"LAMBDA" (for wavelength).  User supplied values are
converted to internal Measurement Set units using the spectral window
sensitive reference frequency.

If only a single UVDIST is specified, all rows that exactly match the
given UVDIST are selected.  When UVDIST is given as a
\hyperref{range}{range (see Section }{)}{Sec:RANGE} in the format
N0$\sim$N1[UNIT] (where N0 and N1 are valid numbers), all rows
corresponding to the uv-distance between N0 and N1 (N0 and N1
included) are selected.

Rows can also be selected via boolean expressions.  When specified in
the format "$>$UVDIST", all rows with uv-distance greater than the
given uv-distance (converted to the appropriate units) are selected.
When specified in the format "$<$UVDIST", all rows with uv-distance
less than the given uv-distance (converted to the appropriate units)
are selected.

To selected rows with uv-distance within an equal range on either side
of a given value, UVDIST can be specified as a percentage of the given
value in the format N\%.  All rows with uv-distance between +/-N
percent of the given uv-distance in appropriate units are selected.

The full uv-distance selection expression is a comma-separated list of
any of the above mentioned uv-distance specifications.  E.g.

\begin{itemize}
\item uvdist={\tt 100Klambda} selects all baselines for which
  $\sqrt{u^2+v^2}$ is equal to 100 K$\lambda$.
\item uvdist={\tt 100Km} selects all baselines for which
  $\sqrt{u^2+v^2}$ is equal to 100 Km.
\item uvdist={\tt 100$\sim$200Klambda} selects all baselines for which
  $\sqrt{u^2+v^2}$ is in the range [100, 200] K$\lambda$.
\item uvdist={\tt $>$100Klambda} selects all baselines for which
  $\sqrt{u^2 + v^2}$ is greater than 100 K$\lambda$.
\item uvdist={\tt $<$100Klambda} selects all baselines for which
  $\sqrt{u^2 + v^2}$ is less than 100 K$\lambda$.
\end{itemize}

\section{Frequency Selection}

Frequency selection expression consists of two specifications
separated by colon (':') in the form:
\begin{verbatim}
      SPWSPEC[:CHANSPEC]
\end{verbatim}
where SPW is the spectral window specification and CHANSPEC is the
optional frequency specification for selection within the selected
spectral windows.  When channel specification is omitted, all channels
of the selected SPW are selected.

SPWSPEC and CHANSPEC allow use of semi-colon separated lists.  As a
result, list of SPWSPEC can be given in two ways: (1) a semi-colon
separated list, (2) coma separated list.  This allows simple
selections to remain simple and more complex selections consistent
with the syntax for CHANSPEC list.

\subsection{Spectral Window Specification Syntax}

Spectral windows (SPW) specification can be of the following types:
\begin{enumerate}
\item an integer ID 
\item a name (as a literal 
\hyperref{string}{string (see Section}{)}{Sec:STRINGS} for exact match
or a regular expression/pattern)
\item a frequency value (value with a unit).  
\end{enumerate}

\subsubsection{Selection by ID}

SPWSPEC can be single integer, a list or a range of integers.  It can also be
a list of boolean expressions involving IDs.  E.g.
\begin{itemize}
\item spwspec="$>$ID" will select all SPWs with ID greater than the specified
  value.
\item spwspec="$<$ID" will select all SPWs with ID lesser than the specified
  value.
\item spwspec={\tt 1,2,3} selects spectral window IDs 1,2 and 3
\item spwspec={\tt 1;2;3} same as above.  This style can be used along
  with CHANSPEC
\item spwspec={\tt 1$\sim$3} same as above
\end{itemize}

\subsubsection{Selection by name}

SPWSPEC can be a name or a list of names which will be matched against
the NAME column of the SPECTRAL\_WINDOW.  The name can be
a string for literal matching, or a regular expression or a pattern.
All SPWs that match the given name will be selected.  E.g.
\begin{itemize}
\item spwspec="LBAND" will select {\it a} SPW named ``{\tt LBAND}''.
\item spwspec="SUBBAND*" will select all SPWs with the name starting with ``{\tt SUBBAND}''.
\item spwspec="SUBBAND*0" will select all SPWs with name starting with ``{\tt
    SUBBAND}'' and ending with ``{\tt 0}''.
\end{itemize}

\subsubsection{Selection by frequency}
SPWSPEC can also be constructed using the reference frequency of the
SPWs.  The reference frequency is defined as the average of the
frequency corresponding to the first and the last channel for each
SPW.  A single frequency specification is used for exact match with
the reference frequency.  A \hyperref{range}{range (see Section
}{)}{Sec:RANGE} of frequencies are used to select all SPWs with the
reference frequencies within the given range.  The allowed units are
Hz, KHz, MHz, GHz or THz.  E.g.
\begin{itemize}
\item spwspec="$>$FREQ" will select all SPWs, the reference frequencies of
  which are greater than the given frequency converted to Hz.
\item spwspec="$<$FREQ" will select all SPWs, the reference frequencies of
  which are greater than the given frequency converted to Hz.
\item spwspec={\tt 327MHz} selects spectral window with a reference
  frequency equal to 327.0 MHz
\item spwspec={\tt 327$\sim$610MHz} selects all spectral windows with
  reference frequencies in the range [327.0, 610.0] MHz.
\item spwspec={\tt 1421MHz, 1422MHz, 1423MHz} selects SPWs with reference
  frequency 1421.0, 1422.0 and 1423.0 MHz.
\item spwspec={\tt 1421MHz; 1422MHz; 1423MHz} same as above.  This style
  can be used along with CHANSPEC.
\item spwspec={\tt $>$327MHz} selects all spectral windows with reference
  frequency greater than 327.0 MHz
\item spwspec={\tt $<$327MHz} selects all spectral windows with reference
  frequency less than 327.0 MHz
\end{itemize}

\subsection{Channel Specification Syntax}

Channel specification\footnote{\it The \MSS\ module is currently
  used to only parse the channel selection expression to produce the
  START,STOP,STEP tuples.  No channel based selection is actually
  applied to the data.  The list of tuples per SPW is passed to the
  application program layer and the interpretation of the tuples for
  actual selection depends on the application programmer.} (referred
to as CHANSPEC in the following description) is a START, STOP, STEP
tuple corresponding to the first frequency channel, the last frequency
channel and the step size to increment from the first to the last
channel.  The START and STOP part of the tuple can be
\hyperref{range}{range (see Section }{)}{Sec:RANGE} specification for
the range [START, STOP] followed by an optional STEP size.

START and STOP part of the tuple can be specified as a single integer
or physical quantity or as a \hyperref{range}{range (see Section
}{)}{Sec:RANGE} of integers or physical quantities.  A single integer
is treated as a channel index and the tuple corresponds to [ID,ID,1].
A single physical quantity is matched with the exact frequency value
of the channels and tuple of matched channel index is constructed as
[ID,ID,1].  A \hyperref{range}{range (see Section }{)}{Sec:RANGE} of
integers given as N0$\sim$N1 is used to construct a tuple [N0,N1,1].
Similarly for a range of physical quantities.

If a START,STOP part of the tuple specification is followed by
"\char94 STEP", the STEP is used as the third value of the tuple.
STEP specification is a single integer or physical quantity.
E.g. 0$\sim$10\char94 2 is converted to a START, STOP, STEP tuple
[0,10,2].

A channel selection expression is a semi-colon separated list of
channel specifications.  E.g.

\begin{itemize}
\item chanspec={\tt 1;2;3} selects channels 1,2 and 3.
\item chanspec={\tt 1$\sim$3} selects channels 1,2 and 3.
\item chanspec={\tt 0$\sim$10\char94 2} selects channels in the range
  [0,10] with a step size of 2
\item chanspec={\tt 1421MHz} selects a frequency channel corresponding to
  the frequency 1421.0 MHz
\item chanspec={\tt 1421$\sim$1500MHz} selects all channels in the range
  [1412.0, 1500.0] MHz
\item chanspec={\tt 1421$\sim$1500MHz\char94 10KHz} selects all channels
  in the range [1421.0, 1500.0] MHz in steps of 10 KHz.
\item chanspec={\tt 1421$\sim$1500MHz\char94 10KHz ; 0$\sim$10\char94 2 ;
  20 ; 30; 40} selects all channels in the range [1421.0, 1500.0] MHz
  in steps of 10KHz, all channels with indexes in the range [0,10] in
  steps of 2 channels and channels 10, 20 and 30.
\end{itemize}

\subsection{ Frequency Selection Syntax}

The specifications for SPW and channels can be combined to form a
fully qualified frequency selection expression of the form
SPWSPEC[:CHANSPEC] (square brackets indicate that :CHANSPEC is
optional).  A frequency selection expression is a comma-separated list
of SPWSPEC[:CHANSPEC] specifications.  Channel selections apply to all
SPWs selected by the SPWSPEC on the left of ':'.  E.g.

\begin{itemize}
\item freq={\tt LBAND:1421$\sim$1500MHz\char94 10KHz ,
  327MHz:300$\sim$400MHz, 0$\sim$4:0$\sim$10\char94 2 , 5:20;30;40}

       selects 

\begin{itemize}
	\item all channels corresponding to channels in the range
          [1421.0, 1500.0] MHz for the SPW named "LBAND", and
	\item all channels corresponding to the range [300.0,
          400.0]MHz for the SPW with a reference frequency of 327.0
          MHz, and
	\item Channels in the range [0,10] in steps of 2 for all SPWs
          with IDs in the range [0,4], and
	\item Channels 20, 30 and 40 for SPW 5
\end{itemize}          

\item freq={\tt 1421Mhz;1422Mhz;1423Mhz :
  0;1;2;10$\sim$20;30$\sim$100$\sim$10 ,0$\sim$3:10$\sim$30}

	 selects

\begin{itemize}
    \item Channels 0, 1, 2 for SPWs with reference frequency of
      1421.0, 1422.0 and 1423.0 MHz.
    \item Channels 10 to 20 in step of 1 channel for SPWs with
      reference frequency of 1421.0, 1422.0 and 1423.0 MHz.
    \item Channels 30 to 100 in steps of 10 channel for SPWs with
      reference frequency of 1421.0, 1422.0 and 1423.0 MHz.
    \item Channels 10 to 30 in step of 1 channel for SPW IDs 0 to 3 in
      step of 1.
\end{itemize}          

\end{itemize}          

Figure~\ref{FIG:SPW} shows an example frequency setup which makes
clear the need to separate the full frequency selection expression
into SPWSPEC and CHANSPEC parts.  SPW0 covers the frequency range
1.0--2.0~GHz with SPW1 overlapping in the range 1.6--1.7~GHz, with a
reference frequency of 1.5~GHz and 1.65~GHz respectively.  Even for
the overlapping range of frequencies, the selection syntax must allow
selection of channels from only SPW0 or only SPW1 or channels from
both.  With independent specifications for SPW and channel selection,
selection expressions can be constructed to select channels from SPW0
\underline{\bf or} SPW1 or from SPW0 \underline{\bf and} SPW1. E.g.
\begin{itemize}
\item spw= ``{\tt * : 1.6$\sim$1.7GHz}'' will select all channels from
  SPW0 \underline{\it and} SPW1 that are in the range
\item spw= ``{\tt 1.5$\sim$1.65GHz : 1.6$\sim$1.7GHz}'' is the same as
  above (selecting SPWs via reference frequency specification)
\item spw=``{\tt 1.5MHz : 1.6$\sim$1.7GHz}'' will select all channels
  from \underline{only} SPW0 that are in the range
\item spw=``{\tt 0 : 1.6$\sim$1.7GHz}'' will select all channels
  from \underline{only} SPW0 that are in the range
\item spw=``{\tt 1.65MHz : 1.6$\sim$1.7GHz}'' same as above, with SPW0
  selected via integer ID
\item spw=``{\tt 1 : 1.6$\sim$1.7GHz}'' same as above, with SPW1
  selected via integer ID

\end{itemize}
\begin{figure}
\centerline{
  \includegraphics[width=10cm]{FreqSettingExample.png}\qquad
}
\caption{Frequency setup with two overlapping SPWs.}
\label{FIG:SPW}

\end{figure}
      
\subsubsection{Notes}

\begin{enumerate}
\item For channel specifications of the type {\tt
  N1$\sim$N2:c0;c1;c2;c3MHz} the list of channel selection is applied
  to all SPWs in the range [N0, N1].  c3 is converted from physical
  units to channel index by using the channel width from SPW N1. Is it
  better to use the min. chan. among the selected SPWs?

\item If channel range is out of bounds, it will be brought within
  bounds per SPW.  If the lower limit of a range is greater than the
  available outer limit, exception is generated.  If the lower limit
  is less than zero, it is set to zero.  If upper limit is greater
  than the available outer limit, it is set to the available outer
  limit.

  If a single channel specification is greater than the available
  outer limit, an exception is thrown.  If it is less than zero, it is
  set to zero.

\item For ranges of physical values, it is assumed that the spectral
  window sub-table's CHAN\_FREQ column has ordered list of channel
  frequencies.
\end{enumerate}

\section{Polarization Selection}

The structure of the Measurement Set allows independent set up for the
frequency and polarization description of the data\footnote{The
  combined main-table descriptor for spectral windows and polarization
  is the Data Description ID (DDID).  DDID represents a two-level
  indirection based on the the Spectral Window and Polarization
  sub-tables (which are the real astrophysically relevant parameters
  of the database).}.  E.g., it is valid to have data at 1420MHz, with
some fraction of the data recorded with only parallel hand
polarizations (e.g. "RR" and "LL") and some fraction of the data
recorded in full polarization mode (e.g. "RR", "LL", "RL", and "LR").
Note however that a polarization set up describes a spectral window
and not the individual frequency channels in a spectral window.

Consequently, polarization selection expressions may need to be
qualified with the spectral window and polarization ID specification
as well.  Therefore, current the polarization selection expressions
are of the type {\tt [SPW:]POL}\footnote{A full specification of the
  type {\tt [[POLID:][SPWID:]POL} or {\tt [DDID::]POL} will be
    implemented in future.}.  The {\tt SPW} part of such expressions
  follow the syntax of the Spectral Window Selection expression (see
  Section~\ref{SPWEXPR}) -- except that the channel specifications are
  not allowed here.

As with other expressions, the polarization selection expression also
consists of comma separated list of full specifications.  The
separator for lists for the individual parts of the specification
(i.e. {\tt SPW}, {\tt POL}, etc.) is semi-colon. However note that if
the optional qualifiers are omitted (i.e., {\tt SPW} etc.), either of
the separators can be used (comma or semi-colon).  Thus {\tt "RR;LL"}
is equivalent to {\tt "RR,LL"}.

The {\tt POL} specification is a semi-colon separated list of
polarization products (i.e., it is a baseline based selection).
E.g. {\tt POL} can be {\tt "RR"} or {\tt "LL"} or {\tt "RR;LR"} or
{\tt "RR;LL;LR;RL"}, etc.  Without the qualifiers, comma can also be
used as a separater.  Polarization specifications in the list can be
in any order.  A number of {\tt [SPW:]POL} specifications can be given
as a comma separated list.  E.g.

\begin{itemize}
\item "poln=RR" will select data corresponding to RR polarization
  product only.
\item "poln=RR,LL,LR,RL" will select all polarization products.
\item "poln=RR ; LL ; LR ; RL" same as the previous expression.
\item "poln=0:RR;LL , 1:LR;RL'' will select RR and LL from spectral
  window 0 and LR and RL from spectral window 1.
\end{itemize}

\section{"Scan intent'' Based Selection}

"Scan intent" selection is based on the entries in the {\tt
  "OBS\_MODE"} column of the {\tt "STATE"} sub-table.  The main table
of a Measurement Set has the {\tt "STATE\_ID"} column containing the
row number of the {\tt "STATE"} sub-table appropriate for each row in
the main table.  The {\tt "OBS\_MODE"} column of the {\tt STATE}
sub-table contains strings describing the observational intent.
These intents are referred to as "scan intents" and the scan-intent
expressions in the \MSS\ module can be used for data selection
based on these intents.

\subsection{Syntax}

The scan-intent selection expression is a comma-separated list of
specifications.  Each specification can be a \hyperref{string}{string (see Section
}{)}{Sec:STRINGS} , an integer or an
integer \hyperref{range}{range (see Section }{)}{Sec:RANGE}.  As in other such expressions, a range $[N0,N1]$ can be
specified as {\tt N0$\sim$N1} (see Section~\ref{Sec:RANGE}).  \hyperref{String}{String (see Section
}{)}{Sec:STRINGS}  can
be regular expressions or patterns or quoted-strings for as-is
matching (see Section~\ref{Sec:STRINGS}). 

A single scan can have multiple scan-intents represented by a
comma-separated list of strings like {\tt
  "CALIBRATE\_BANDPASS.UNSPECIFIED,CALIBRATE\_AMPLI.UNSPECIFIED"}.
Each of these comma-separated components are referred to as the
scan-intent components.  All string specifications in scan-intent
expression are matched against {\it each} of these comma-separated
components.  Scans with {\it any} of the scan-intent components
matching the string(s) in the scan-intent expression are selected.
E.g. {\tt scanintent=*CAL*, *BAND*} will select all scans which have
the strings {\tt "CAL"} or {\tt "BAND"}.

To allow selection based on scan-intent components, scan-intent
selection specifications can also be ampersand-separated ({\tt '\&'})
list strings.  Only those scans, at least one scan-intent components
of which match {\it all} the ampersand-separated components are
selected.  E.g. {\tt scanintent=*CAL* \& *BAND*} will select only
those scans the intent strings of which contain the strings {\tt
  "CAL"} {\it and} {\tt "BAND"}.  See
Section~\ref{Sec:SCANINTENTEXAMPLES} for more examples.

\subsection{Examples}
\label{Sec:SCANINTENTEXAMPLES}
Table~\ref{Tab:SCANINTENT} shows an example-table of scan-intents.
Table~\ref{Tab:SCANINTENTEXPR} shows a list of some scan-intent
selection expressions and the corresponding list of selected scan
numbers from Table~\ref{Tab:SCANINTENT}.

\begin{table}[ht!]
\caption{Example scan-intent table}
\begin{center}
\begin{tabular}{|c|l|}
\hline
\small {Scan No.} & \small{Scan-intent strings}\\
\hline
   0    &  \small{\tt CALIBRATE\_BANDPASS, CALIBRATE\_PHASE}\\
   1    &  \small{\tt CALIBRATE\_BANDPASS, CALIBRATE\_AMPLI}\\
   2    &  \small{\tt CALIBRATE\_BANDPASS, CALIBRATE\_AMPLI, CALIBRATE\_PHASE}\\
   3    &  \small{\tt AMPLI\_UNSPECIFIED, PHASE\_UNSPECIFIED}\\
\hline
\end{tabular}
\end{center}
\label{Tab:SCANINTENT}
\end{table}
\begin{table}[h!]
\caption{Examples of scan-intent selection expressions for intents
shown in Table~\ref{Tab:SCANINTENT}}
\begin{center}
% This LaTeX table template is generated by emacs 23.2.1
\begin{tabular}{|l|l|l|}
\hline
{\bf Scan-intent}& {\bf Selected}& {\bf Remarks}\\
{\bf selection expression}&{\bf scans}& \\
\hline
\hline
{\small \tt CALI*}   & 0,1,2 & \\
\hline
{\small \tt *PHASE}   & 0,2   & Matches {\small \tt CALIBRATE\_PHASE} but \\
                      &       & not {\small \tt PHASE\_UNSPECIFIED} \\
\hline
{\small \tt *UNSPEC*} & 3     & \\
\hline
{\small \tt *AMPLI, *PHASE} & 1,2 & {\small \tt *AMPLI} matches {\small \tt CALIBRATE\_AMPLI}; \\
                            &     & {\small \tt *PHASE} matches {\small \tt CALIBRATE\_PHASE} \\
\hline
{\small \tt *AMP*} & 1,2,3 & {\small \tt *AMP*} matches {\small \tt CALIBRATE\_AMPLI} and \\
                   &       & {\small \tt AMPLI\_UNSPECIFIED} \\
\hline
{\small \tt *BAND \& *PHASE} & 0,2 & {\small \tt *BAND} and {\small \tt *PHASE} are  simultaneous present \\
                             &     & for scans 0 and 2 only \\
\hline
{\small \tt AMP* \& *PHASE*} & 3 & {\small \tt *PHASE*} matches scans 0,2,3. {\small \tt AMP*} matches \\
                             &   & only scan 3. \\
\hline
{\small \tt *BAND \& *PHASE* \& *AMP*} & 2 & Only scan that matches {\small \tt *BAND} {\it and} \\
                                       &   & {\small \tt *PHASE*} {\it and} {\small \tt *AMP*} is scan 2 \\
\hline
{\small \tt *BAND \& *PHASE*, AMPLI*} & 0,2,3 & {\small \tt *BAND \& *PHASE} selects scans 0,2. \\
                                      &       & {\small \tt AMPLI*} selects scan 3 \\
\hline
\end{tabular}
\end{center}
\label{Tab:SCANINTENTEXPR}
\end{table}

\section{Scan/Sub-array Selection}

Scan and sub-arrays selections are purely integer ID based selections.
The syntax for the specification of both these is therefore identical.

\subsection{Syntax}

Scan and Sub-array selection specification is a single integer (INT)
or a \hyperref{range}{range (see Section }{)}{Sec:RANGE} of
integers(N0$\sim$N1).  Scans and sub-arrays can also be selected via
boolean expressions of the type "$>$INT", "$>$=INT", "$<$INT" or
"$<$=INT"\footnote{{\it Programmers note:} The getScanList()
  (getSubArrayList() for sub-arrays) method will return the list
  generated from INT,INT,... or INT$\sim$INT or "$<$INT"
  specification.  For "$>$INT" specification, the returned list will
  be number from INT part of "$>$INT" up to the maxScans (maxArrays for
  sub-arrays) set via MSSelection::setMaxScan()
  (MSSelection::setMaxArray() for sub-arrays).  The default value of
  maxScans/maxArrays is {\tt std::standard\_limits$<$int$>$::max()}
  (i.e. the maximum value an integer can take on a machine).  It is
  done this way since there is no efficient way of generating a list
  of SCAN/ARRAY IDs present in the data and "$>$INT" is an unbounded
  list of integers.  The list of scans IDs in the data can be {\bf
    probably} generated using the MSRange class - but I think it can
  be quite expensive.  So if it is necessary to know the precise list
  of scans selected using the "$>$INT" specification, the application
  programs will have to use MSRange class to get the range in the
  data.  An intersection of the list from MSRange and the list from
  MSSelection.getScanList() will be the actual selected scans
  (intersection of two CASA vectors can be done using the
  set\_intersection() global method in MSSelectionTools.h).  }.

Full expression is a comma-separated list of any of the above index
specifications.  E.g.

\begin{itemize}
\item scan={\tt 0,1,2,3}  selects scan numbers 0, 1, 2 and 3
\item scan={\tt 0$\sim$3}      selects scans in the range [0,3]
\item scan={\tt 0$\sim$3,4,5}  selects scans in the range [0,3] and scans 4 and 5 
\item scan={\tt $>$5}       selects all scans greater than 5
\item scan={\tt $<$5}       selects all scans less than 5
\end{itemize}

\newpage
\appendix{}
\section{Appendix: Using the {\tt MSSelection} module for other MS-like Tables}
\newpage
\section{Appendix: General Error Handling}

The \MSS\ sub-system reports errors via the C++ exception
mechanism.  The objects thrown have the following inheritance
hierarchy:

\begin{center}
\begin{verbatim}
                             AipsError
                                 o
                                 |
                                 |
                          MSSelectionError
                                 o
                                 |
                                 |
  MSSelection{Time,Spw,UvDist,Antenna,Scan,Subarray,Poln,State}Error
                                 o
                                 |
                                 |
MSSelection{Time,Spw,UvDist,Antenna,Scan,Subarray,Poln,State}ParseError
\end{verbatim}
\end{center}

All parsing errors are reported by throwing the {\tt
  MSSelection\{Time, Spw, Field, UvDist, Antenna, Scan,
  Subarray,Poln,State\}ParseError} exception.  All other forms of
errors (e.g. illegal \hyperref{range}{range (see Section
}{)}{Sec:RANGE} specification N0$\sim$N1 where N0 $>$ N1) are reported
by throwing an exception of type {\tt MSSelection\{Time, Spw, Field,
  UvDist, Antenna, Scan, Subarray,Poln,State\}Error}.

Hence, to catch all errors thrown from the \MSS\ sub-system,
catch the \MSSelectionError\ object.  For more specific exception
handling, catch the more qualified MSSelection*Error objects.  For
catching only parsing errors, catch the MSSelection*ParseError object.
As is obvious, any un-caught exception from the \MSS\ sub-system
will be caught in the AipsError catch block.

The exceptional error message consists of a human understandable
one-line description of the error, the string which caused the error
and the possible location in the string of the erroneous
character.  E.g.

 Spw Expression: No match found for "LBAN" (near char. 4 in string "LBAN")

\subsection{Error Handlers}

The normal (default) behavior of the parsers is to throw an exception
when an error is encountered during parsing cycle or in the
rule-resolution code.  However there are cases where instead of
throwing an exception, the errors must be collected as they occur and
resolution of the error done at the end of the parsing cycle.  In the
\MSS\ module, this is achieved by installing an error handler
object of type \MSSelectionErrorHandler\footnote{This is also the
  base-class from which all specializations of the error handlers must
  be derived.} in the instance of the \MSS\ object.  This is the
object that is used internally to handle errors in the \MSS\
module.  The default error handler that comes pre-installed simply
throws an exception of the appropriate kind when an error is
encountered, recreating the normal behaviour of the C++ exception
handling mechanism.

To collect errors (and the error messages generated in the process) as
they occur for later resolution, the client-side code can install a
specialization of the error handler of type {\tt MSSelectionLogError},
a derivative of the {\tt MSSelectionErrorHandler}, using the {\tt
  MSSelection::setErrorHandler()} method.  At the appropriate place in
the client code, a call to {\tt
  MSSelectionErrorHandler::reportError()} can be made to display the
collected error messages as warning messages. This behavior can be
changed in a specialization of the {\tt MSSelectionErrorHandler} class
by overloading the {\tt reportError} method.

This mechanism of error handling is currently available for ANTENNA
and STATE (a.k.a. ``intent selection'') selection expressions only.

\newpage
\section{Appendix: Examples}

\begin{table}[h!]
\caption{Summary of the MS used}
\begin{center}
\begin{tabular}{|c|c|c|c|l|c|}
\hline
FIELDID & SPWID &  NChan & Pol & NRows   & Source Name\\
\hline
   0    &  0    &   127  &  RR &  10260  &  0530+135  \\
   1    &  0    &   127  &  RR &  779139 &  05582+16320  \\
   2    &  0    &   127  &  RR &  296190 &  05309+13319  \\
   3    &  0    &   127  &  RR &  58266  &  0319+415      \\
   4    &  0    &   127  &  RR &  32994  &  1331+305      \\
   5    &  1,2  &    1   &  RR,RL,LL,RR  &  23166&  KTIP  \\
\hline
\end{tabular}
\end{center}
\end{table}

\subsection{Example 1}
\begin{verbatim}
--------------------------------------------------------------------
Select field IDs 0,1,2 and field Named KTIP
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: All baselines between antennas named "1" to "10"
       Spw:  0  Channels: 10 to 30 in steps of 1
--------------------------------------------------------------------
sbhatnag@atlas>mssplit
mssplit>inp
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = 0~2,KTIP
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 0:10~30
baseline   = 1~10&
scan       =
array      =
uvdist     =
mssplit>go
Ant1 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Ant2 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Field= [0, 1, 2, 5]
SPW  = [0]
Chan = [10, 30, 1]
Scan = []
Array = []
UVRange = Axis Lengths: [2, 0] []
UV in meters = []
Number selected rows: 99819
\end{verbatim}

\subsection{Example 2}

\begin{verbatim}
--------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: All baselines between antennas named "1" to "10"
       Spw:  All available channels for spw 1 and 2
--------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1,2
baseline   = 1~10&
scan       =
array      =
uvdist     =
mssplit>go
Ant1 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Ant2 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Field= [5]
SPW  = [1, 2]
Chan = SPW 1 : Channels [0, 0, 1]
       SPW 2 : Channels [0, 0, 1]
Scan = []
Array = []
UVRange = Axis Lengths: [2, 0] []
UV in meters = []
Number selected rows: 2376
\end{verbatim}

\subsection{Example 3}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: All baselines between antennas *named* "1" to "10"
       Spw:  SPW ID 0

       No data should be selected
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 0
baseline   = 1~10&
scan       =
array      =
uvdist     =
mssplit>go
Ant1 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Ant2 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Field= [5]
SPW  = [0]
Chan = SPW 0 : Channel [0, 126, 1]
Scan = []
Array = []
UVRange = Axis Lengths: [2, 0] []
UV in meters = []
Number selected rows: 0
\end{verbatim}

\subsection{Example 4}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: All baselines between antennas *named* "1" to "10"
       Spw:  SPW ID 1
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1
baseline   = 1~10&
scan       =
array      =
uvdist     =
mssplit>go
Ant1 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Ant2 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Field= [5]
SPW  = [1]
Chan = SPW 1 : Channels [0, 0, 1]
Scan = []
Array = []
UVRange = Axis Lengths: [2, 0] []
UV in meters = []
Number selected rows: 1188
\end{verbatim}


\subsection{Example 5}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: Between antennas "1" to "3" and "4" to "6"
       Spw:  SPW ID 1
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1
baseline   = 1,2,3&4,5,6
scan       =
array      =
uvdist     =
mssplit>go
Ant1 = [21, 10, 17]
Ant2 = [4, 24, 3]
Field= [5]
SPW  = [1]
Chan = SPW 1 : Channel [0, 0, 1]
Scan = []
Array = []
UVRange = Axis Lengths: [2, 0] []
UV in meters = []
Number selected rows: 198
\end{verbatim}

\subsection{Example 6}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: Error in antenna specification
       Spw:  All spectral windows
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1
baseline   = 1~3 & $~6
uvdist     =
mssplit>go
###AipsError: Antenna Expression: Parse error at or near '$' (near
char. 7 in string "1~3 & $~6")
\end{verbatim}

\subsection{Example 7}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: Use antenna ranges
       Spw:  1
       UVRange: [0,5000] K-Lambda
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1
baseline   = 1~3 & 4~6
scan       =
array      =
uvdist     = 0~5klambda
mssplit>go
Ant1 = [21, 10, 17]
Ant2 = [4, 24, 3]
Field= [5]
SPW  = [1]
Chan = SPW 1 : Channel [0, 0, 1]
Scan = []
Array = []
UVRange = [0, 5000] lambda
Number selected rows: 33
\end{verbatim}

\subsection{Example 8}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: Baselines between antennas "1" to "3" and "4" to "6"
                  and baseline "10"-"11"
       Spw:  1
       UVRange: [0, 5000] K-Lambda
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1
baseline   = 1~3 & 4~6 ; 10&11
scan       =
array      =
uvdist     = 0~5klambda
mssplit>go
Ant1 = [21, 10, 17, 6]
Ant2 = [4, 24, 3, 1]
Field= [5]
SPW  = [1]
Chan = SPW 1 : Channel [0, 0, 1]
Scan = []
Array = []
UVRange = [0, 5000] lambda
Number selected rows: 33
\end{verbatim}

\subsection{Example 9}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: Error in range operator
       Baselines: Baselines between antennas "1" to "3" and "4" to "6"
       Spw:  All spectral windows
       UVRange: [0, 5000] K-Lambda
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = /home/rohir3/sanjay/CASATests/G192.ms/
outms      = tt.ms
field      = K*
time       = 25/22:40:0 - 26/03:30:0
spw        = 1
baseline   = 1~3 & 4~6 ; 10&11
scan       =
array      =
uvdist     = 0~5klambda
mssplit>go
First selected timestamp = 26-Apr-2003/03:20:45.0
###MSSelectionError: MSSelection time error: Parse error at or near
token '-' (near char. 12 in string "25/22:40:0 - 26/03:30:0")
(Did you know we use "~" as the range operator (for a good reason)?)
\end{verbatim}

% \newpage
% \section{Appendix: Formal Grammar Specifications}

% {\tt TEN} in the following refers to the TableExprNode object of the
% {\tt Tables} module of CASA.

% \subsection{Baseline Selection Expression}

% \begin{verbatim}
% %union {
%   const TableExprNode* node;
%   char* str;
%   double dval;
%   Vector<Int>* iv;
%   std::vector<double>* dv;
%   Vector<String>* is;
% }

% %token AT
% %token COMMA
% %token SEMICOLON
% %token AMPERSAND
% %token DASH
% %token NOT
% %token LPAREN
% %token RPAREN
% %token LT
% %token LE
% %token GT
% %token GE

% %token <str> INT
% %token <str> FLOAT
% %token <str> UNIT
% %token <str> QSTRING
% %token <str> REGEX
% %token <str> IDENTIFIER

% %type <node> antennastatement 
% %type <node> indexcombexpr    
% %type <node> baseline         
% %type <node> gbaseline        
% %type <str> identstr          
% %type <dval> flt              
% %type <dval> flint            
% %type <dval> unit             
% %type <dval> flintunit        
% %type <dval> flunit           
% %type <iv> antlist            
% %type <iv> antidrange
% %type <iv> antids
% %type <iv> antid
% %type <iv> stationid
% %type <iv> stationlist
% %type <iv> antatstation
% //%type <iv> antatstationlist
% %type <iv> antcomp
% %type <iv> stancomp
% %type <dv> blength
% %type <dv> blengthlist

%     0 $accept: antennastatement $end

%     1 antennastatement: indexcombexpr

%     2 indexcombexpr: gbaseline
%     3              | indexcombexpr SEMICOLON gbaseline

%     4 @1: /* empty */

%     5 gbaseline: NOT @1 baseline

%     6 @2: /* empty */

%     7 gbaseline: @2 baseline

%     8 baseline: antlist AMPERSAND antlist
%     9         | antlist AMPERSAND
%    10         | antlist
%    11         | antlist AMPERSAND AMPERSAND antlist
%    12         | antlist AMPERSAND AMPERSAND
%    13         | antlist AMPERSAND AMPERSAND AMPERSAND
%    14         | blengthlist

%    15 identstr: IDENTIFIER
%    16         | UNIT

%    17 stationid: IDENTIFIER
%    18          | QSTRING
%    19          | REGEX

%    20 antid: identstr
%    21      | QSTRING
%    22      | REGEX

%    23 antidrange: INT
%    24           | INT DASH INT

%    25 stationlist: stationid
%    26            | stationlist COMMA stationid

%    27 antlist: antids
%    28        | antlist COMMA antids

%    29 antcomp: antid
%    30        | antidrange
%    31        | LPAREN antlist RPAREN

%    32 stancomp: stationid
%    33         | LPAREN stationlist RPAREN

%    34 antatstation: antcomp AT stancomp
%    35             | AT stancomp

%    36 antids: antid
%    37       | antidrange
%    38       | antatstation

%    39 blengthlist: blength
%    40            | blengthlist COMMA blength

%    41 blength: LT flunit
%    42        | LE flunit
%    43        | GT flunit
%    44        | GE flunit
%    45        | flt DASH flt
%    46        | flt DASH flt unit
%    47        | flintunit DASH flintunit

%    48 flunit: flint
%    49       | flintunit

%    50 flintunit: flint unit

%    51 unit: UNIT

%    52 flint: flt
%    53      | INT

%    54 flt: FLOAT
% \end{verbatim}


% \subsection{Frequency Selection Expression}

% \begin{verbatim}

% %union {
%   const TableExprNode* node;
%   Block<TableExprNode>* exprb;
%   TableExprNodeSetElem* elem;
%   TableExprNodeSet* settp;
%   Float fval2[2], fval4[4],fval;
%   char * str;
%   Int ival;
%   Vector<Float>* fv;
%   Vector<Int>* iv;
% }


% %token SQUOTE
% %token <str> IDENTIFIER
% %token COMMA

% %token LPAREN
% %token RPAREN
% %token WHITE
% %token COLON
% %token CARET
% %token SEMICOLON

% %token <str> UNIT
% %token <str> INT
% %token <str> FNUMBER
% %token <str> QSTRING
% %token <str> REGEX

% %type <node> SpwStatement
% %type <node> FullSpec
% %type <node> FullExpr
% %type <fval2> OneFreq
% %type <fval4> FreqRange
% %type <fval2> Physical
% %type <fval4> IndexRange
% %type <fval4> PhyRange
% %type <iv>    Spw
% %type <fval4> FListElements
% %type <fv>   FreqList
% %type <fval> PhyVal
% %type <fval2> UnitCode

% %nonassoc GT GE LT LE NE COMMA DASH AMPERSAND SEMICOLON COLON CARET
% %right TILDA

%     0 $accept: SpwStatement $end

%     1 SpwStatement: FullExpr
%     2             | LPAREN FullExpr RPAREN

%     3 PhyVal: FNUMBER

%     4 UnitCode: UNIT

%     5 Physical: PhyVal UnitCode

%     6 PhyRange: Physical DASH Physical
%     7         | PhyVal DASH PhyVal UnitCode
%     8         | PhyRange CARET Physical
%     9         | CARET Physical

%    10 IndexRange: PhyVal DASH PhyVal
%    11           | IndexRange CARET PhyVal
%    12           | CARET PhyVal

%    13 FreqRange: IndexRange
%    14          | PhyRange

%    15 OneFreq: PhyVal
%    16        | Physical

%    17 FListElements: FreqRange
%    18              | OneFreq

%    19 FreqList: FListElements
%    20         | FreqList SEMICOLON FListElements

%    21 Spw: IDENTIFIER
%    22    | QSTRING
%    23    | REGEX
%    24    | GT OneFreq
%    25    | LT OneFreq
%    26    | DASH OneFreq
%    27    | FreqList

%    28 FullSpec: Spw
%    29         | Spw COLON FreqList

%    30 FullExpr: FullSpec
%    31         | FullExpr COMMA FullSpec
% \end{verbatim}


% \subsection{Field Selection Expression}

% \begin{verbatim}
% %union {
%   const TableExprNode* node;
%   Block<TableExprNode>* exprb;
%   TableExprNodeSetElem* elem;
%   TableExprNodeSet* settp;
%   Int ival[2];
%   char * str;
%   Double dval;
%   Vector<Int>* iv;
%   Vector<String>* is;
% }


% %token EQASS
% %token SQUOTE
% %token <str> IDENTIFIER
% %token COMMA

% %token LBRACKET
% %token LPAREN
% %token RBRACKET
% %token RPAREN
% %token LBRACE
% %token RBRACE
% %token WHITE

% %token <str> INT
% %token <str> QSTRING
% %token <str> REGEX

% %token COLON
% %token SEMICOLON

% %type <node> fieldstatement
% %type <node> indexcombexpr
% %type <iv> indexlist
% %type <iv> fieldidrange
% %type <iv> fieldidlist
% %type <iv> fieldid
% %type <iv> fieldidbounds

% %nonassoc EQ EQASS GT GE LT LE NE COMMA DASH AMPERSAND

%     0 $accept: fieldstatement $end

%     1 fieldstatement: indexcombexpr
%     2               | LPAREN indexcombexpr RPAREN

%     3 indexcombexpr: indexlist

%     4 fieldid: IDENTIFIER
%     5        | QSTRING
%     6        | REGEX

%     7 fieldidrange: INT
%     8             | INT DASH INT

%     9 fieldidbounds: LT INT
%    10              | GT INT
%    11              | GT INT AMPERSAND LT INT

%    12 fieldidlist: fieldid
%    13            | fieldidrange
%    14            | fieldidbounds

%    15 indexlist: fieldidlist
%    16          | indexlist COMMA fieldidlist
% \end{verbatim}


% \subsection{Scan/Sub-Array Selection Expression}

% \begin{verbatim}
% %union {
%   const TableExprNode* node;
%   Block<TableExprNode>* exprb;
%   TableExprNodeSetElem* elem;
%   TableExprNodeSet* settp;
%   Int ival[2];
%   char * str;
%   Double dval;
%   std::vector<Int>* iv; // std::vectors have push_back, insert, etc.
%   Vector<String>* is;
% }


% %token EQASS
% %token SQUOTE
% %token <str> IDENTIFIER
% %token COMMA

% %token LBRACKET
% %token LPAREN
% %token RBRACKET
% %token RPAREN
% %token LBRACE
% %token RBRACE
% %token WHITE

% %token <str> INT
% %token <str> QSTRING
% %token <str> REGEX

% %token COLON
% %token SEMICOLON

% %type <node> scanstatement
% %type <node> compoundexpr
% %type <node> scanboundsexpr
% %type <node> scanidbounds
% %type <iv> scanids

% %nonassoc EQ EQASS GT GE LT LE NE COMMA DASH AMPERSAND

%     0 $accept: scanstatement $end

%     1 scanstatement: compoundexpr

%     2 compoundexpr: scanids
%     3             | scanboundsexpr
%     4             | compoundexpr COMMA scanids
%     5             | compoundexpr COMMA scanboundsexpr

%     6 scanidbounds: LT INT
%     7             | GT INT
%     8             | LE INT
%     9             | GE INT
%    10             | GE INT AMPERSAND LE INT
%    11             | GT INT AMPERSAND LT INT

%    12 scanboundsexpr: scanidbounds

%    13 scanids: INT
%    14        | INT DASH INT
% \end{verbatim}


% \subsection{Time Selection Expression}

% \begin{verbatim}
% %union {
%   const TableExprNode* node;
%   Block<TableExprNode>* exprb;
%   TableExprNodeSetElem* elem;
%   TableExprNodeSet* settp;
%   const MEpoch* tval;
%   Int ival;
%   Double dval;
%   Double dval3[3];
%   Int ival3[3];
%   TimeFields timeFields;
% }

% %token <ival> NUMBER
% %token <dval> FNUMBER
% %token SQUOTE

% %token DASH
% %token LT
% %token GT
% %token COLON
% %token COMMA
% %token SLASH
% %token DOT
% %token PERCENT
% %token STAR

% %token UNKNOWN

% %type <node> timestatement
% %type <node> timeexpr
% %type <node> singletimeexpr
% %type <node> rangetimeexpr
% %type <node> upboundtimeexpr
% %type <node> lowboundtimeexpr
% %type <timeFields> yeartimeexpr
% %type <dval> wildFloat
% %type <ival> wildNumber
% %type <ival> tFields
% %type <dval3> timeObj
% %type <ival> yFields
% %type <ival3> yearObj

% %left OR
% %left AND
% %nonassoc GT LT LE COLON SLASH
% %left PLUS MINUS
% %left TIMES DIVIDE MODULO
% %nonassoc UNARY
% %nonassoc NOT
% %right POWER

%     0 $accept: timestatement $end

%     1 timestatement: timeexpr
%     2              | timestatement COMMA timeexpr

%     3 timeexpr: singletimeexpr
%     4         | rangetimeexpr
%     5         | lowboundtimeexpr
%     6         | upboundtimeexpr

%     7 wildNumber: STAR
%     8           | NUMBER

%     9 wildFloat: wildNumber
%    10          | FNUMBER

%    11 singletimeexpr: yeartimeexpr

%    12 rangetimeexpr: yeartimeexpr DASH yeartimeexpr
%    13              | yeartimeexpr PLUS yeartimeexpr

%    14 lowboundtimeexpr: GT yeartimeexpr

%    15 upboundtimeexpr: LT yeartimeexpr

%    16 tFields: wildNumber COLON
%    17        | COLON

%    18 yFields: wildNumber SLASH
%    19        | SLASH

%    20 timeObj: tFields tFields wildFloat
%    21        | tFields tFields
%    22        | tFields wildFloat
%    23        | tFields
%    24        | wildNumber

%    25 yearObj: yFields yFields wildNumber
%    26        | yFields yFields

%    27 yeartimeexpr: yearObj SLASH timeObj
%    28             | yearObj
%    29             | timeObj
% \end{verbatim}

% \subsection{UV-distance Selection Expression}

% \begin{verbatim}
% %union {
%   const TableExprNode* node;
%   char * str;
%   Double dval;
% }

% %token <str> UNIT
% %token <dval> FNUMBER
% %token COLON
% %token COMMA
% %token PERCENT

% %type <dval> fnumwithunits
% %type <node> uvwdiststatement
% %type <node> uvwdistexprlist
% %type <node> uvwdistexpr
% %left UNIT
% %right PERCENT
% %nonassoc EQ EQASS GT GE LT LE NE DASH COLON 

%     0 $accept: uvwdiststatement $end

%     1 uvwdiststatement: uvwdistexprlist

%     2 uvwdistexprlist: uvwdistexpr
%     3                | uvwdistexprlist COMMA uvwdistexpr

%     4 fnumwithunits: FNUMBER
%     5              | FNUMBER UNIT

%     6 uvwdistexpr: fnumwithunits
%     7            | FNUMBER DASH fnumwithunits
%     8            | LT fnumwithunits
%     9            | GT fnumwithunits
%    10            | fnumwithunits COLON FNUMBER PERCENT
% \end{verbatim}

\end{document}
