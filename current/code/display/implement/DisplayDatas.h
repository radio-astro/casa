//# DisplayDatas.h: The DisplayDatas module - AIPS++ data-based display
//# Copyright (C) 1994,1995,1996,1997,1998,1999,2000
//# Associated Universities, Inc. Washington DC, USA.
//#
//# This library is free software; you can redistribute it and/or modify it
//# under the terms of the GNU Library General Public License as published by
//# the Free Software Foundation; either version 2 of the License, or (at your
//# option) any later version.
//#
//# This library is distributed in the hope that it will be useful, but WITHOUT
//# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
//# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
//# License for more details.
//#
//# You should have received a copy of the GNU Library General Public License
//# along with this library; if not, write to the Free Software Foundation,
//# Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.
//#
//# Correspondence concerning AIPS++ should be addressed as follows:
//#        Internet email: aips2-request@nrao.edu.
//#        Postal address: AIPS++ Project Office
//#                        National Radio Astronomy Observatory
//#                        520 Edgemont Road
//#                        Charlottesville, VA 22903-2475 USA
//#
//# $Id$

#ifndef TRIALDISPLAY_DISPLAYDATAS_H
#define TRIALDISPLAY_DISPLAYDATAS_H

#include <display/DisplayDatas/LatticeAsRaster.h>
#include <display/DisplayDatas/LatticeAsContour.h>

namespace casa { //# NAMESPACE CASA - BEGIN

// <module>
//
// <summary>
// A module providing classes to draw AIPS++ data in specific ways
// </summary>
//
// <use visibility=export>
//
// <reviewed reviewer="None yet" date="yyyy/mm/dd" demos="">
// </reviewed>
//
// <prerequisite>
// <li> DisplayCanvas
// </prerequisite>
//
// <etymology>
// The module provides various classes that are responsible for
// "displaying" "data"
// </etymology>
//
// <synopsis> 
//
// <h3>Motivation</h3>
//
// The basic drawing devices in the Display Library are the <linkto
// class="PixelCanvas">PixelCanvas</linkto> and the <linkto
// class="WorldCanvas">WorldCanvas</linkto>.  These devices know
// nothing about what data look like, what kind of object will draw on
// the devices, and in what circumstances these devices will be used.
// The only thing they define is the interface of how to draw on them
// and the way that they communicate with other objects, for example
// the event handlers.
//
// <h3>The DisplayDatas</h3>
//
// Thus classes are needed to transform data into objects that are
// understood by the canvases.  These are the DisplayDatas, which
// generate drawing commands based on data and some algorithm which
// translates that data into a visual representation: eg. a contouring
// algorithm.  Exactly how the data is represented is entirely defined
// by the DisplayDatas, and as long as it can be done using the
// primitives of the WorldCanvas, there are no restrictions.  To
// display data in a new way, all that must be written is a new
// DisplayData which generates appropriate drawing instructions, and
// can be asked to carry out those instructions.  The DisplayDatas
// should be thought of as the "workhorses" of the AIPS++ Display
// Library.
//
// <h3>The WorldCanvasHolder</h3>
//
// The administration of a number of DisplayDatas on one WorldCanvas
// is handled by the WorldCanvasHolder class.  The WorldCanvasHolder
// provides methods to register and unregister DisplayDatas.  The
// WorldCanvasHolder installs handlers on the WorldCanvas for each
// event generated by the WorldCanvas.  Since its main task is to
// allow more than one DisplayData object to draw on a WorldCanvas at
// any one time, the WorldCanvasHolder must pass WorldCanvas events on
// to the registered DisplayDatas, either directly or indirectly.  For
// example, motion events (which occur when the pointer is moved
// across the WorldCanvas) will be immediately passed on to all
// DisplayDatas for processing, while refresh events (which occur when
// the WorldCanvas needs to redraw itself, eg. following a resize) are
// managed by the WorldCanvasHolder itself, which may ask only a
// subset of the registered DisplayDatas to redraw themselves, and
// also ensures that raster-type DisplayDatas draw before vector-type
// DisplayDatas.
//
// Some DisplayDatas will consist of a sequence of "drawings," for
// example, a set of channel maps in a data cube.  The DisplayDatas
// are built with such sequences in mind, and the appropriate "frame"
// to draw is negotiated between the WorldCanvasHolder and the one or
// more DisplayDatas actually registered with the WorldCanvasHolder.
// A sequence of images is not restricted to separate planes through a
// data volume: it could comprise blinking between two or more images,
// or rendering views of data along different lines-of-sight.
//
// To control what is displayed on a WorldCanvas, the programmer can
// put restrictions on a WorldCanvasHolder and on DisplayDatas. Only
// the DisplayDatas whose internal restrictions actually match those
// of the WorldCanvasHolder will be allowed to draw on the
// WorldCanvas.  Indeed, an important part of the support for
// DisplayDatas comprising sequences of images is implemented by
// placing restrictions on the WorldCanvas that are appropriate to the
// desired image plane.
//
// </synopsis>
//
// </module>


} //# NAMESPACE CASA - END

#endif

